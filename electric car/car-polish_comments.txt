//czyszczenie konsoli
clc;
clear;
xdel;
// zmiana katalogu roboczego na C:\
chdir("C:\"); // wymagane są uprawnienia administratora
//mkdir("Projekt");// utwórz katalog projekt
cd("Projekt");
disp(pwd()); // sprawdzenie katalogu roboczego
clear x;clear ans;
 
 
 
 
// definicja parametrów pojazdu
// masa, wspolczynnik powiekszenia masy, opór toczenia, opory aerodynamiczne,pole powierzchni czołowej,wydajność,rekuperacja
car_t=struct('m',2500,   'fm',1.05,   'Crr',0.012,   'Cx',0.28,   'A',2.8, 'eff', 0.9, 'rec',0.4);
 
// dodatkowe parametry
// predkosc wiatru, gestosc powietrza, przyspieszenie ziemskie
other_t=struct('Vw',0, 'rho',1.2, 'g',9.81);
 
 
 
 
 
// otwarcie pliku z danymi
filename = "nowa-trasa.csv"; // nazwa pliku w którym została nagrana trasa -
myfile = csvRead(filename); // czytanie pliku csv
time_str_vect = csvRead(filename,",", ".", 'string');// wczytanie pliku jako string do formatowania godziny
 
 
// utworzenie wszystkich wymaganych wektoró
// utworzenie wektora prędkości
speed_km_vect=myfile(:,6);
speed_km_vect(1)=[]; // odrzuc pierwszy element(tekst)
//disp(speed_km_vect); // wyswietlenie wektora predkosci
 
// utworzenie wektora dystansu
distance_vect=myfile(:,7);
distance_vect(1)=[];
//disp(distance_vect); // wyswietl wektor dystansu
 
// utworzenie wektora wysokosci
altitude_vect=myfile(:,5);
altitude_vect(1)=[];
//disp(altitude_vect); // wyswietlenie wektora wysokosci
 
 
// utwórz wektor predkosci
time_str_vect(:,1)=[];// odrzuc niepotrzebne kolumny
time_str_vect(:,2:8)=[];
time_str_vect(1,:)=[];
//  z formatu 2017-11-25 11:04:30.168  do 2004 06 10 17 00 12.00
// year montt day hour minutes seconds miliseconds - rok,miesiac, dzien godziny minuty, sekundy,milisekundy
time_str_vect=strsubst(time_str_vect,'-',' '); // uformuj stringa do skladni wymaganej przez funckję etime
time_str_vect=strsubst(time_str_vect,':',' '); // zamien':' na ' '
time_str_vect=strsubst(time_str_vect,'.',' ');
 
row_cnt = size(time_str_vect,'r'); // pobeirz rozmiar
cnt =1;
time_vect(1)=[0];
delta_time_vect=[];
 
while cnt < row_cnt
    // zmienne potrzbne do obliczenia czasu
    trash=[]; year=[]; month=[]; day=[];
    hour=[]; minute=[]; second=[]; ms=[];
    // ufomrmuj czas do stringa, funckja etime odpowiada za obliczenie upływu czasu pomiędzy
    [trash,year,month,day,hour,minute,second,ms]=msscanf(1,time_str_vect(cnt),"%d %d %d %d %d %d %d %e %e");
    second=second+ms/1000;
    t1=[year month day hour minute second];
    // uformuj kolejny czas jako t2
    [trash,year,month,day,hour,minute,second,ms]=msscanf(1,time_str_vect(cnt+1),"%d %d %d %d %d %d %d %e %e");
    second=second+ms/1000; // recznie napraw blad milisekund
    t2=[year month day hour minute second];
    time_vect(cnt+1)=time_vect(cnt)+etime(t2,t1);// finaly form time vector  - końcowe utworzenie wektora czasowego
    delta_time_vect(cnt)=etime(t2,t1); // obliczenie czasu w sekundach, z uzyciem wczeniej uformowanych stringow t1 oraz t2
    cnt=cnt+1;
end
// usun wszystkie niepotrzebne zmienne
clear row_cnt; clear cnt; clear myfile;
clear second; clear trash; clear year;
clear month; clear day; clear hour;
clear minute; clear ms; clear filename;
clear t1; clear t2; clear time_str_vect;
// teraz mamy utworzone wszystkie potrzebne wektory
   
 
 
// zamiana jednostek km/h na m/s
row_cnt=size(speed_km_vect,'r');
cnt=1;
speed_vect=[];
while cnt<=row_cnt
    speed_vect(cnt)=speed_km_vect(cnt)/3.6;
    cnt=cnt+1;
end
clear row_cnt; clear cnt;
   
 
 
 
// obliczenie wektoru przuspieszenia
// obliczenie prawostronnej pochodnej (v2-v1)/dt
acceleration_vect =[];
row_cnt=size(speed_vect,'r');
cnt=1;
 
while(cnt<=(row_cnt))
    // to change !!
    if(cnt==row_cnt)then // recznie napraw dlugosc wektora
        acceleration_vect(cnt)=0;
        break;
    end
    // obliczenie pochodnej przyspieszenia
    acceleration_vect(cnt)=(speed_vect(cnt+1)-speed_vect(cnt))/delta_time_vect(cnt);
    cnt=cnt+1;
end
clear row_cnt; clear cnt;
 
 
 
// obliczenie wartosci w stopniach
tilt_rad_vect=[]; // wartość wyrażona w radianach
tilt_dgr_vect=[]; // wartość wyrażona w stopniach
row_cnt=size(distance_vect,'r');
cnt=1;
while(cnt<row_cnt)
    a =(altitude_vect(cnt+1)-altitude_vect(cnt));
    b =(distance_vect(cnt+1)-distance_vect(cnt))*1000;
    tilt_rad_vect(cnt)=a/b;
    if(tilt_rad_vect(cnt)>1) then // jezeli sinx>1 przerwij (oznacza bład w odczycie z gps, gdzie kąt nachylenia jest wiekszy niz 90stopni)
        disp("BROKEN ALTITUDE VECT!!! - ");
        abort;
    end;
    tilt_rad_vect(cnt)=asin(tilt_rad_vect(cnt));
    tilt_dgr_vect(cnt)=(tilt_rad_vect(cnt)*360)/(2*%pi); // zmiana jednostek (radianow na stopnie)
    cnt=cnt+1;
end
 
clear row_cnt; clear cnt; clear a; clear b;
 
 
 
 
 
 
// obliczenie zużytej energii
force_vect=[];  // wektor siły
power_vect=[];  // wektor mocy
 
text_buffer =[]; // string do formowania informacji wyswietlanych w konsoli
row_cnt=size(speed_vect,'r');
cnt=1;
 
disp("nr odcinka, faza ruchu, przyspieszenie [m/s^2], kąt nachylenia [stopnie], Fa,Fb,Ft,Fw - poszczególne siły [N], F - łączna siła [N], P -moc [W/s] ");
while cnt<row_cnt
    text_buffer = string(cnt)+" odcinek, ";
    if acceleration_vect(cnt)>0 then // przyspiezenia
       text_buffer=text_buffer+"przyspieszanie, ";
       text_buffer=text_buffer+"a="+string(acceleration_vect(cnt))+" kąt="+string(tilt_dgr_vect(cnt));
       Fb=acceleration_vect(cnt)*car_t.m*car_t.fm// siła bezwładności
       Fa=0.5*((speed_vect(cnt)-other_t.Vw)).^2*other_t.rho*car_t.A*car_t.Cx;// opór aerodynamiczny Fa
       Fw=car_t.m*other_t.g*sin(tilt_rad_vect(cnt));    // siła oporu wzniesienia
       Ft=car_t.Crr*car_t.m*other_t.g*cos(tilt_rad_vect(cnt)); //siła oporu toczenia
       force_vect(cnt)=Fa+Fb+Fw+Ft; // siła wypadkowa, czyli suma wszystkich działających sił
       text_buffer=text_buffer+" Fa="+string(Fa)+" Fb="+string(Fb)+" Fw="+string(Fw)+" Ft="+string(Ft);
       text_buffer=text_buffer+" F="+string(force_vect(cnt));
       power_vect(cnt)=force_vect(cnt)*speed_vect(cnt+1); // obliczenie mocy
       text_buffer=text_buffer+" P="+string(power_vect(cnt));
    elseif acceleration_vect(cnt)<0 then // hamowanie
       text_buffer=text_buffer+"hamowanie,      ";
       text_buffer=text_buffer+"a="+string(acceleration_vect(cnt))+" kat="+string(tilt_dgr_vect(cnt));
       Fb=acceleration_vect(cnt)*car_t.m*car_t.fm;
       Fa=0.5*((speed_vect(cnt)-other_t.Vw)).^2*other_t.rho*car_t.A*car_t.Cx;  
       Fw=car_t.m*other_t.g*sin(tilt_rad_vect(cnt));  
       Ft=car_t.Crr*car_t.m*other_t.g*cos(tilt_rad_vect(cnt));
       force_vect(cnt)=Fa+Fw+Ft+Fb;
       text_buffer=text_buffer+" Fa="+string(Fa)+" Fb="+string(Fb)+" Fw="+string(Fw)+" Ft="+string(Ft);
       text_buffer=text_buffer+" F="+string(force_vect(cnt));
       power_vect(cnt)=force_vect(cnt)*speed_vect(cnt+1);
       text_buffer=text_buffer+" P="+string(power_vect(cnt));
    else // prędkośc = const (stała)
       text_buffer=text_buffer+"stala predkosc, ";
       text_buffer=text_buffer+"a="+string(acceleration_vect(cnt))+" kat="+string(tilt_dgr_vect(cnt));
       Fa=0.5*((speed_vect(cnt)-other_t.Vw)).^2*other_t.rho*car_t.A*car_t.Cx;// V^2*rho*A*Cx  
       Fw=car_t.m*other_t.g*sin(tilt_rad_vect(cnt)); // m*g*sin(alfa in radians) - kąt alfa wyrazony w radianach
       Ft=car_t.Crr*car_t.m*other_t.g*cos(tilt_rad_vect(cnt));
       force_vect(cnt)=Fa+Fw+Ft;
       text_buffer=text_buffer+" Fa="+string(Fa)+" Fw="+string(Fw)+" Ft="+string(Ft);
       text_buffer=text_buffer+" F="+string(force_vect(cnt));
       power_vect(cnt)=force_vect(cnt)*speed_vect(cnt);
       text_buffer=text_buffer+" P="+string(power_vect(cnt));
    end
    // wyświetlenie informacji o poszczególnych danych
    disp(text_buffer);
    cnt=cnt+1;
end
disp(" "); // nowa linia
disp(" "); //
disp(" "); //
clear row_cnt; clear cnt; clear Fa; clear Fb; clear Fw; clear Ft; clear text_buffer;
 
 
//moc przy wzięciu pod uwagę sprawności silnika oraz jednostki napędowej
row_cnt=size(power_vect,'r');
cnt=1;
while cnt<=row_cnt
    if power_vect(cnt)>0
        power_vect(cnt)=power_vect(cnt)/0.9; // 90% sprawności mocy
    else
        power_vect(cnt)=power_vect(cnt)*0.9; // z uwzglednieniem rekuperacji
    end
    cnt=cnt+1;
end
clear row_cnt; clear cnt;
 
 
// reczne naprawienie dlugosci wektorow
power_vect=cat(1,power_vect,0); //  dodaj  wartośc 0 na końcu wektora
tilt_dgr_vect=cat(1,tilt_dgr_vect,0); //  dodaj  wartośc 0 na końcu wektora
force_vect=cat(1,force_vect,0); //  dodaj  wartośc 0 na końcu wektora
tilt_rad_vect=cat(1,tilt_rad_vect,0); //  dodaj  wartośc 0 na końcu wektora
 
 
 
// obliczenie zuzycia energii przy 100% rekuperacji, oraz braku rekuperacji
work =[];
work = inttrap(time_vect,power_vect); // obliczenie całki mocy w jednostce czasu
work=work/3600;// zmiana jednostek z W/s na W/h
disp("Zuzyta energia przy 100% odzysku - " + string(work)+"W/h"); // Wyswietlenie zuzytej energii przy 100% odzysku
 
row_cnt=size(power_vect,'r');
cnt=1;
P_rec_vect=[]; // tymczasowe wektory mocy: z rekuperacja
P_zero_vect=[]; // bez rekuperacji
while cnt<=row_cnt
    if (power_vect(cnt)>0) then
        P_rec_vect(cnt)=power_vect(cnt);
        P_zero_vect(cnt)=power_vect(cnt);
    else
        P_rec_vect(cnt)=power_vect(cnt)*car_t.rec;
        P_zero_vect(cnt)=0;
    end
    cnt=cnt+1;
end
clear row_cnt; clear cnt;
 
work_rec = inttrap(time_vect,P_rec_vect);
work_rec=work_rec/3600;// zmiana jednostek z W/s na W/h
work_zero = inttrap(time_vect,P_zero_vect);
work_zero=work_zero/3600;// zmiana jednostek z W/s na W/h
disp("Zuzyta energia przy zdefiniowanym odzysku - " + string(work_rec)+"W/h");
disp("Zuzyta energia przy braku odzysku - " + string(work_zero)+"W/h");
 
 
 
 
show_plots = 1;// define 0 - ukryj wykres, 1- wyświetl wykres  
 
if(show_plots~=0) then
    scf(1);  //wykonanie wykresu
    subplot(311);
    plot2d(time_vect,speed_km_vect);  // wykres zaleznosci predkosci od czasu
    xtitle('V=f(t)', 't, [s]', 'V, [km/h]') //wyswietlenie jednostek przy odpowiednich osiach
    subplot(312);
    plot2d(time_vect,distance_vect);     //wykres zaleznosci przejechanej drogi od czasu
    xtitle('l=f(t)', 't, [s]', 'l, [km]')    
    subplot(313);
    plot2d(time_vect,acceleration_vect);   // wykres zaleznosci przyspieszenia od czasu
    xtitle('a=f(t)', 't, [s]', 'a, [m/s^2]')
   
    scf(2);
    subplot(311);
    plot2d(time_vect,force_vect);      //  wykres zaleznosci siły od czasu
    xtitle('F=f(t)', 't, [s]', 'F, [N]')
    subplot(312);
    plot2d(time_vect,power_vect);
    xtitle('P=f(t)', 't, [s]', 'P, [W]')   // wykres zaleznosci mocy od czasu
    subplot(313);
    plot2d(time_vect,tilt_dgr_vect);
    xtitle('altitude=f(t)', 't, [s]', 'tilt, [degree]') // wykres zaleznosci wysokosci od stopnia nachylenia powierzchni
end
 
 
 
 
 
 
// funkcja aproksymacji akumulatora , naładowane pojedyncze ogniwo ma wartosc napiecia 4,33V (soc(1)=4,33V)
function w=e(soc)// wybrano akumulator (li-ion - litowo jonowy)
 w = n*(-1.031*exp(-35*soc)+3.685+0.2156*soc+0.1178*soc*soc+0.3201*soc*soc*soc);  // funkcja opisujaca rozłądowanie akumulatora
endfunction
 
//lepsza funkcja aproksymująca stan naladowania ogniwa zaczerpnięta z opracowania pt. ,,State of charge estimation for Li-ion battery based on extended Kalman filter,,
function w=e_new(soc)// lion
 w = n*( -3.836*soc*soc*soc*soc + 10.32*soc*soc*soc-9.671*soc*soc + 4.162*soc+3.19);
endfunction
 
 
n = 84; // bateria złożona z ogniw li-ion (Litowo-jonowy) w konfiguracji 84S50P.
 
Cn = 160; // pojemnosc wyrazona w amperogodzinach
Cns = Cn * 3600; // pojemnosc wyrazona w kulombach
Rw = n*(0.025/Cn) // rezystancja wewnetrzna ogniwa = 25mohm
Pmax = e(1)^2/(4*Rw); // moc maksymalna w stanie dopasowania
 
vector_length = size(time_vect,'r');
 
 
 
// Zuzycie energii akumulatora na badanym odcinku z rekuperacją
j =1;
soc_rec(j) = 1.0;
q(j) = Cns*soc_rec(j);
 
 
while e_new(soc_rec(j))^2-4*Rw*P_rec_vect(j) >= 0
   
    i_rec(j) = (e_new(soc_rec(j))-sqrt(e_new(soc_rec(j))^2-4*Rw*P_rec_vect(j)))/(2*Rw); // obliczony prąd
    u_rec(j) = e_new(soc_rec(j))-i_rec(j)*Rw;                                           // obliczone napiecie
   
    p_rec(j) = i_rec(j)*u_rec(j);                                                       // obliczona moc
   
    //q(j+1) = q(j) - i_rec(j) * delta_time_vect(j); //euler - funkcja eulera
    // huen ------------  funkcja huena - W metodzie tej zamiast stałej wartości pochodnej obliczonej na początku przedziału, jak to było w metodzie Eulera, oblicza się pochodną również na końcu przedziału
    q_new(j) = q(j) - i_rec(j) * delta_time_vect(j);             //ładunek
    soc_new(j) = q_new(j) / Cns;                                 // stan naładowania
    i_new(j) = (e_new(soc_new(j))-sqrt(e_new(soc_new(j))^2-4*Rw*P_rec_vect(j)))/(2*Rw); // tutaj metoda obliczania pradu dla parametru e_new
    q(j+1) = q(j)-(i_rec(j) + i_new(j)) * delta_time_vect(j)/2;
    //----------------
   
   
    soc_rec(j+1) = q(j+1) / Cns; // wylicz nowa wartosc soc
    if soc_rec(j) >1  then soc_rec(j)=1 end
   
    if u_rec(j) <= n*2.9 then break;end //break
    j = j + 1;  // inc j
    if(j>size(delta_time_vect,'r')) then break end;
end
 
 
 
// reczne naprawienie dlugosci wektorow
i_rec(vector_length)=0;
p(vector_length)=0;
u_rec(vector_length)=u_rec(vector_length-1);
 
 
scf(3);
subplot(311);
plot2d(time_vect, i_rec);
xtitle('i(t) (z rekuperacja)','t, s', 'i, A');
subplot(312);
plot2d(time_vect, u_rec);
xtitle('u(t) (z rekuperacja)','t, s', 'u, V');
subplot(313);
plot2d(time_vect, soc_rec);
xtitle('SoC(t) (z rekuperacja)','t, s', 'SoC');
 
disp('-----------------------------------------------------------------------------');
disp('Zuzycie energii akumulatora na badanym odcinku z rekuperacją');
disp('stan naładowania akumulatora po przejechaniu trasy z rekuperacją '+string(car_t.rec*100)+'% SOC='+string(soc_rec(vector_length)));
disp('napiecie poczatkowe U_pocz='+string(u_rec(1))+'V, napiecie koncowe U_konc='+string(u_rec(vector_length))+'V');
 
 
 
 
 
// bez rekuperacji
j =1;
soc_zero(j) = 1.0;
q(j) = Cns*soc_zero(j);
 
 
while e_new(soc_zero(j))^2-4*Rw*P_zero_vect(j) >= 0
   
    i_zero(j) = (e_new(soc_zero(j))-sqrt(e_new(soc_zero(j))^2-4*Rw*P_zero_vect(j)))/(2*Rw);
    u_zero(j) = e_new(soc_zero(j))-i_zero(j)*Rw;
   
    p_zero(j) = i_zero(j)*u_zero(j);
   
    //q(j+1) = q(j) - i_zero(j) * delta_time_vect(j); // metoda eulera
    // huen ------------
    q_new(j) = q(j) - i_zero(j) * delta_time_vect(j);
    soc_new(j) = q_new(j) / Cns;
    i_new(j) = (e_new(soc_new(j))-sqrt(e_new(soc_new(j))^2-4*Rw*P_zero_vect(j)))/(2*Rw);
    q(j+1) = q(j)-(i_zero(j) + i_new(j)) * delta_time_vect(j)/2;
    //----------------
   
   
    soc_zero(j+1) = q(j+1) / Cns; // soc value - wartośc stanu naładowania
    if soc_zero(j) >1  then soc_zero(j)=1 end
   
    if u_zero(j) <= n*2.9 then break;end //break
    j = j + 1;  // inc j
    if(j>size(delta_time_vect,'r')) then break end;
end
 
 
 
// reczne naprawienie dlugosci wektorów
i_zero(vector_length)=0;
p(vector_length)=0;
u_zero(vector_length)=u_zero(vector_length-1);
 
 
scf(4);
subplot(311);
plot2d(time_vect, i_zero);
xtitle('i(t) (bez rekuperacji)','t, s', 'i, A');
subplot(312);
plot2d(time_vect, u_zero);
xtitle('u(t) (bez rekuperacji)','t, s', 'u, V');
subplot(313);
plot2d(time_vect, soc_zero);
xtitle('SoC(t) (bez rekuperacji)','t, s', 'SoC');
 
disp('-----------------------------------------------------------------------------');
disp('Zuzycie energii akumulatora na badanym odcinku bez rekuperacji');
disp('stan naładowania akumulatora po przejechaniu trasy SOC='+string(soc_zero(vector_length)));
 
    disp('napiecie poczatkowe U_pocz='+string(u_zero(1))+'V, napiecie koncowe U_konc='+string(u_zero(vector_length))+'V');